// Code generated by "enumer -text -transform lower -trimprefix countUnit -type countUnit"; DO NOT EDIT.

package digest

import (
	"fmt"
	"strings"
)

const (
	_countUnitName_0      = "one"
	_countUnitLowerName_0 = "one"
	_countUnitName_1      = "k"
	_countUnitLowerName_1 = "k"
	_countUnitName_2      = "m"
	_countUnitLowerName_2 = "m"
	_countUnitName_3      = "g"
	_countUnitLowerName_3 = "g"
	_countUnitName_4      = "t"
	_countUnitLowerName_4 = "t"
	_countUnitName_5      = "p"
	_countUnitLowerName_5 = "p"
	_countUnitName_6      = "e"
	_countUnitLowerName_6 = "e"
)

var (
	_countUnitIndex_0 = [...]uint8{0, 3}
	_countUnitIndex_1 = [...]uint8{0, 1}
	_countUnitIndex_2 = [...]uint8{0, 1}
	_countUnitIndex_3 = [...]uint8{0, 1}
	_countUnitIndex_4 = [...]uint8{0, 1}
	_countUnitIndex_5 = [...]uint8{0, 1}
	_countUnitIndex_6 = [...]uint8{0, 1}
)

func (i countUnit) String() string {
	switch {
	case i == 1:
		return _countUnitName_0
	case i == 1000:
		return _countUnitName_1
	case i == 1000000:
		return _countUnitName_2
	case i == 1000000000:
		return _countUnitName_3
	case i == 1000000000000:
		return _countUnitName_4
	case i == 1000000000000000:
		return _countUnitName_5
	case i == 1000000000000000000:
		return _countUnitName_6
	default:
		return fmt.Sprintf("countUnit(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _countUnitNoOp() {
	var x [1]struct{}
	_ = x[countUnitOne-(1)]
	_ = x[countUnitK-(1000)]
	_ = x[countUnitM-(1000000)]
	_ = x[countUnitG-(1000000000)]
	_ = x[countUnitT-(1000000000000)]
	_ = x[countUnitP-(1000000000000000)]
	_ = x[countUnitE-(1000000000000000000)]
}

var _countUnitValues = []countUnit{countUnitOne, countUnitK, countUnitM, countUnitG, countUnitT, countUnitP, countUnitE}

var _countUnitNameToValueMap = map[string]countUnit{
	_countUnitName_0[0:3]:      countUnitOne,
	_countUnitLowerName_0[0:3]: countUnitOne,
	_countUnitName_1[0:1]:      countUnitK,
	_countUnitLowerName_1[0:1]: countUnitK,
	_countUnitName_2[0:1]:      countUnitM,
	_countUnitLowerName_2[0:1]: countUnitM,
	_countUnitName_3[0:1]:      countUnitG,
	_countUnitLowerName_3[0:1]: countUnitG,
	_countUnitName_4[0:1]:      countUnitT,
	_countUnitLowerName_4[0:1]: countUnitT,
	_countUnitName_5[0:1]:      countUnitP,
	_countUnitLowerName_5[0:1]: countUnitP,
	_countUnitName_6[0:1]:      countUnitE,
	_countUnitLowerName_6[0:1]: countUnitE,
}

var _countUnitNames = []string{
	_countUnitName_0[0:3],
	_countUnitName_1[0:1],
	_countUnitName_2[0:1],
	_countUnitName_3[0:1],
	_countUnitName_4[0:1],
	_countUnitName_5[0:1],
	_countUnitName_6[0:1],
}

// countUnitString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func countUnitString(s string) (countUnit, error) {
	if val, ok := _countUnitNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _countUnitNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to countUnit values", s)
}

// countUnitValues returns all values of the enum
func countUnitValues() []countUnit {
	return _countUnitValues
}

// countUnitStrings returns a slice of all String values of the enum
func countUnitStrings() []string {
	strs := make([]string, len(_countUnitNames))
	copy(strs, _countUnitNames)
	return strs
}

// IsAcountUnit returns "true" if the value is listed in the enum definition. "false" otherwise
func (i countUnit) IsAcountUnit() bool {
	for _, v := range _countUnitValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for countUnit
func (i countUnit) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for countUnit
func (i *countUnit) UnmarshalText(text []byte) error {
	var err error
	*i, err = countUnitString(string(text))
	return err
}
